% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add_type.R
\name{add_type}
\alias{add_type}
\alias{add_line}
\alias{add_point}
\alias{add_col}
\alias{add_errorbar}
\alias{add_smooth}
\alias{add_sf}
\title{Add Plot Element}
\usage{
add_type(plot, type = NULL, mapping = aes(), ..., data = NULL, move = 0)

add_line(
  plot,
  y = NULL,
  x = NULL,
  colour = getOption("plot2.colour", "ggplot2"),
  linetype,
  linewidth,
  ...,
  inherit.aes = NULL,
  move = 0,
  legend.value = NULL
)

add_point(
  plot,
  y = NULL,
  x = NULL,
  colour = getOption("plot2.colour", "ggplot2"),
  size,
  shape,
  ...,
  inherit.aes = NULL,
  move = 0,
  legend.value = NULL
)

add_col(
  plot,
  y = NULL,
  x = NULL,
  colour = getOption("plot2.colour", "ggplot2"),
  colour_fill,
  width,
  ...,
  inherit.aes = NULL,
  move = 0,
  legend.value = NULL
)

add_errorbar(
  plot,
  min,
  max,
  colour = getOption("plot2.colour", "ggplot2"),
  width = 0.5,
  ...,
  inherit.aes = NULL,
  move = 0
)

add_smooth(
  plot,
  y = NULL,
  x = NULL,
  colour = getOption("plot2.colour", "ggplot2"),
  linetype,
  linewidth,
  formula,
  method,
  se,
  ...,
  inherit.aes = NULL,
  move = 0,
  legend.value = NULL
)

add_sf(
  plot,
  sf_data,
  colour = getOption("plot2.colour_sf", "grey50"),
  colour_fill = getOption("plot2.colour_sf_fill", getOption("plot2.colour", "ggplot2")),
  size = 2,
  linewidth = 0.1,
  datalabels = NULL,
  datalabels.colour = "black",
  datalabels.size = 3,
  datalabels.angle = 0,
  datalabels.font = getOption("plot2.font"),
  datalabels.nudge_y = 2500,
  ...,
  inherit.aes = FALSE
)
}
\arguments{
\item{plot}{a \code{ggplot2} plot}

\item{type}{a \code{ggplot2} geom name, all geoms are supported. Full function names can be used (e.g., \code{"geom_line"}), but they can also be abbreviated (e.g., \code{"l"}, \code{"line"}). These geoms can be abbreviated by their first character: area (\code{"a"}), boxplot (\code{"b"}), column (\code{"c"}), histogram (\code{"h"}), jitter (\code{"j"}), line (\code{"l"}), point (\code{"p"}), ribbon (\code{"r"}), violin (\code{"v"}).}

\item{mapping}{a mapping created with \code{\link[ggplot2:aes]{aes()}} to pass on to the geom}

\item{data}{data to use in mapping}

\item{move}{number of layers to move the newly added geom down, e.g., \code{move = 1} will place the newly added geom down 1 layer, thus directly under the highest layer}

\item{x, y}{aesthetic arguments}

\item{colour, colour_fill}{colour of the line or column, will be evaluated with \code{\link[=get_colour]{get_colour()}}. If \code{colour_fill} is missing but \code{colour} is given, \code{colour_fill} will inherit the colour set with \code{colour}.}

\item{linetype, linewidth, shape, size, width, ...}{arguments passed on to the geom}

\item{inherit.aes}{a \link{logical} to indicate whether the default aesthetics should be inherited, rather than combining with them}

\item{legend.value}{text to show in an additional legend that will be created. Since \code{ggplot2} does not actually support this, it may give some false-positive warnings or messages, such as "Removed 1 row containing missing values or values outside the scale range".}

\item{min, max}{minimum (lower) and maximum (upper) values of the error bars}

\item{formula}{Formula to use in smoothing function, eg. \code{y ~ x},
\code{y ~ poly(x, 2)}, \code{y ~ log(x)}. \code{NULL} by default, in which case
\code{method = NULL} implies \code{formula = y ~ x} when there are fewer than 1,000
observations and \code{formula = y ~ s(x, bs = "cs")} otherwise.}

\item{method}{Smoothing method (function) to use, accepts either
\code{NULL} or a character vector, e.g. \code{"lm"}, \code{"glm"}, \code{"gam"}, \code{"loess"}
or a function, e.g. \code{MASS::rlm} or \code{mgcv::gam}, \code{stats::lm}, or \code{stats::loess}.
\code{"auto"} is also accepted for backwards compatibility.  It is equivalent to
\code{NULL}.

For \code{method = NULL} the smoothing method is chosen based on the
size of the largest group (across all panels). \code{\link[stats:loess]{stats::loess()}} is
used for less than 1,000 observations; otherwise \code{\link[mgcv:gam]{mgcv::gam()}} is
used with \code{formula = y ~ s(x, bs = "cs")} with \code{method = "REML"}. Somewhat anecdotally,
\code{loess} gives a better appearance, but is \eqn{O(N^{2})}{O(N^2)} in memory,
so does not work for larger datasets.

If you have fewer than 1,000 observations but want to use the same \code{gam()}
model that \code{method = NULL} would use, then set
\verb{method = "gam", formula = y ~ s(x, bs = "cs")}.}

\item{se}{Display confidence band around smooth? (\code{TRUE} by default, see
\code{level} to control.)}

\item{sf_data}{an 'sf' \link{data.frame}}

\item{datalabels}{a column of \code{sf_data} to add as label below the points}

\item{datalabels.colour, datalabels.size, datalabels.angle, datalabels.font}{properties of \code{datalabels}}

\item{datalabels.nudge_y}{is \code{datalabels} is not \code{NULL}, the amount of vertical adjustment of the datalabels (positive value: more to the North, negative value: more to the South)}
}
\value{
a \code{ggplot} object
}
\description{
Quickly and conveniently add a new 'geom' to an existing \code{plot2}/\code{ggplot} model. Like \code{\link[=plot2]{plot2()}}, these functions support tidy evaluation, meaning that variables can be unquoted. Better yet, they can contain any function with any output length, or any vector. They can be added using the pipe (new base \R's \verb{|>} or tidyverse's \verb{\%>\%}).
}
\details{
The function \code{\link[=add_line]{add_line()}} will add:
\itemize{
\item \code{\link[ggplot2:geom_abline]{geom_hline()}} if only \code{y} is provided and it contains one unique value;
\item \code{\link[ggplot2:geom_abline]{geom_vline()}} if only \code{x} is provided and it contains one unique value;
\item \code{\link[ggplot2:geom_path]{geom_line()}} in all other cases.
}

The function \code{\link[=add_errorbar]{add_errorbar()}} only adds error bars to the \code{y} values, see \emph{Examples}.
}
\examples{
head(iris)
                 
p <- iris |>
  plot2(x = Sepal.Length,
        y = Sepal.Width,
        category = Species,
        zoom = TRUE)
p
  
# if not specifying x or y, current plot data are taken
p |> add_line()

p |> add_smooth()
  
# single values for add_line() will plot 'hline' or 'vline'
# even considering the `category` if set
p |> 
  add_line(y = mean(Sepal.Width))

# set `colour` to ignore existing colours
# and use `legend.value` to add a legend
p |> 
  add_line(y = mean(Sepal.Width),
           colour = "red",
           legend.value = "Average")

# also works with facets
iris |>
  plot2(x = Sepal.Length,
        y = Sepal.Width,
        facet = Species) |>
  add_line(y = mean(Sepal.Width),
           legend.value = "Average")

iris |>
  plot2(x = Sepal.Length,
        y = Sepal.Width,
        facet = Species) |>
  add_line(y = range(Sepal.Width),
           legend.value = "Range")


p |> 
  add_line(x = mean(Sepal.Length)) |> 
  add_line(y = mean(Sepal.Width))
  
p |>
  add_point(x = median(Sepal.Length),
            y = median(Sepal.Width),
            shape = 13,
            size = 25,
            show.legend = FALSE)
  
# multiple values will just plot multiple lines
p |> 
  add_line(y = fivenum(Sepal.Width),
           colour = "blue",
           legend.value = "Tukey's Numbers")
  
p |> 
  add_line(y = quantile(Sepal.Width, c(0.25, 0.5, 0.75)),
           colour = c("red", "black", "red"),
           linewidth = 1)
  
# use move to move the new layer down
p |> 
  add_point(size = 5,
            colour = "lightpink",
            move = -1)

# providing x and y will just plot the points as new data,
p |> 
  add_point(y = 2:4,
            x = 5:7,
            colour = "red",
            size = 5)
# even with expanded grid if x and y are not of the same length
p |> 
  add_point(y = 2:4,
            x = 5:8,
            colour = "red",
            size = 5)

# any mathematical transformation of current values is supported
df <- data.frame(var_1 = c(1:100),
                 var_2 = rnorm(100, 100, 25),
                 var_3 = rep(LETTERS[1:5], 5))
df |>
  plot2(var_1, var_2) |> 
  add_line(y = mean(var_2), 
           linetype = 3,
           legend.value = "Average") |>
  add_col(y = var_2 / 5,
          width = 0.25,
          colour = "blue",
          legend.value = "This *is* **some** symbol: $beta$")

# plotting error bars was never easier
library("dplyr", warn.conflicts = FALSE)
df2 <- df |> 
  as_tibble() |> 
  slice(1:25) |>
  filter(var_1 <= 50) |> 
  mutate(error1 = var_2 * 0.9,
         error2 = var_2 * 1.1)

df2

df2 |> 
  plot2(var_1, var_2, var_3, type = "col", datalabels = FALSE, alpha = 0.25, width = 0.75) |> 
  # adding error bars was never easier - just reference the lower and upper values
  add_errorbar(error1, error2)

# adding sf objects is just as convenient as all else
netherlands |> 
  plot2()
netherlands |> 
  plot2(colour_fill = "viridis", colour_opacity = 0.75)
netherlands |> 
  plot2(colour_fill = "viridis", colour_opacity = 0.75) |>
  # add the same sf object, but now with empty fill and other options
  add_sf(netherlands,
         colour = "black",
         colour_fill = NA,
         linetype = 2,
         linewidth = 0.5)
}
